~pracma::interp1(x = mu_spl$t,
y = mu_spl$x,
xi = .x$t,
method = "linear"))
phi_i <- purrr::map(df_list,
~apply(pca_ll$phi, 2, function(phij) {
pracma::interp1(x = pca_ll$workGrid,
y = phij,
xi = .x$t,
method = "linear")
}))
f_i <- purrr::map(df_list, ~pracma::interp1(x = fhat$t,
y = fhat$x,
xi = .x$t,
method = "linear"))
varphi_i <- purrr::map(seq_along(df_list),
~list(
t = df_list[[.x]]$t,
x = (df_list[[.x]]$x - mu_i[[.x]]) * phi_i[[.x]] / f_i[[.x]]
)
)
# cdf_hat <- list(t = xout,
#                 x = cdf_series(xi = df_age$Age,
#                                x = xout,
#                                J = 12,
#                                thresh = TRUE))
cdf_hat <- list(t = fhat$t,
x = c(pracma::cumtrapz(x = fhat$t,
y = fhat$x)))
# estimate scores using nn
xi_list <- purrr::map(varphi_i,
~apply(.x$x, 2, function(varphi) {
mc_int(x = .x$t,
varphi = varphi,
cdf = cdf_hat)$varphi_int
})
)
df_mc <- do.call('rbind', xi_list)
colnames(df_mc) <- paste0("xi", seq_len(pca_ll$selectK))
# estimate scores using sample mean
xi_emp <- purrr::map(varphi_i, ~colMeans(.x$x))
df_emp <- do.call('rbind', xi_emp)
colnames(df_emp) <- paste0("xi", seq_len(pca_ll$selectK))
# estimate scores using riemann sums
xi_riemann <- purrr::map(varphi_i,
~apply(.x$x, 2, function(xij) pracma::trapz(x = .x$t,
y = xij)))
df_riemann <- do.call('rbind', xi_riemann)
colnames(df_riemann) <- paste0("xi", seq_len(pca_ll$selectK))
# scale to divide by empirical eigenvalues
df_scaled_mc <- scale(df_mc, center = FALSE)
df_scaled_emp <- scale(df_emp, center = FALSE)
df_scaled_riemann <- scale(df_riemann, center = FALSE)
# mc_kmeans <- kmeans(x = df_scaled_mc, centers = 2, nstart = 50)
# emp_kmeans <- kmeans(x = df_scaled_emp, centers = 2, nstart = 50)
# riemann_kmeans <- kmeans(x = df_scaled_riemann, centers = 2, nstart = 50)
mc_hclust <- hclust(dist(df_scaled_mc), method = "average")
cut_mc <- cutree(mc_hclust, k = 2)
emp_hclust <- hclust(dist(df_scaled_emp), method = "average")
cut_emp <- cutree(emp_hclust, k = 2)
riemann_hclust <- hclust(dist(df_scaled_riemann), method = "average")
cut_riemann <- cutree(riemann_hclust, k = 2)
# Analysis for clustering
id2_mc <- seq_along(cut_mc)[cut_mc == 2]
id2_emp <- seq_along(cut_emp)[cut_emp == 2]
id2_riemann <- seq_along(cut_riemann)[cut_riemann == 2]
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_mc
L2_emp <- df_norm |>
filter(ID %in% id2_emp) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Empirical Mean)')
L2_emp
L2_riemann <- df_norm |>
filter(ID %in% id2_riemann) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Trapezoidal Rule)')
L2_riemann
?ggplogt
?ggplot
?hue_pal
df_norm
?scale_color_manual
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
scale_color_manual(values = c("830" = "green",
"2574" = "red",
"2930" = "blue",
"3309" = "purple")) +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_mc
hue_pal
?h_al
h_pakl
?hue_pal
?brewer.pal
pal_manual <- brewer.pal(n = 11, type = "qual")
pal_manual <- RColorBrewer::brewer.pal(n = 11, type = "qual")
pal_manual <- RColorBrewer::brewer.pal(n = 11, name = "Paired")
pal_manual
df_norm |>
filter(ID %in% id2_mc)
ID_mc <- df_norm |>
filter(ID %in% id2_mc) |>
select(ID) |>
distinct()
ID_mc
ID_mc$ID
names(pal_manual) <- ID_mc$ID
pal_manual
pal_manual_mc <- RColorBrewer::brewer.pal(n = 11, name = "Paired")
names(pal_manual) <- ID_mc$ID
pal_manual_emp <- RColorBrewer::brewer.pal(n = 5, name = "Paired")
pal_manual_mc
rm(pal_manual)
pal_manual_mc <- RColorBrewer::brewer.pal(n = 11, name = "Paired")
names(pal_manual_mc) <- ID_mc$ID
pal_manual_mc
pal_manual_emp <- RColorBrewer::brewer.pal(n = 5, name = "Paired")
pal_manual_emp
ID_emp <- df_norm |>
filter(ID %in% id2_emp) |>
select(ID) |>
distinct()
ID_emp
ID_emp$ID
names(pal_manual_emp) <- ID_emp$ID
pal_manual_emp
pal_manual_mc["2930"]
?setdiff
intersect(ID_mc$ID, ID_emp$ID)
intersect(ID_mc$ID, ID_emp$ID)
pal_manual_mc[intersect(ID_mc$ID, ID_emp$ID)]
pal_manual_mc[paste0(intersect(ID_mc$ID, ID_emp$ID))]
pal_manual_emp
pal_manual_emp[intersect(ID_mc$ID, ID_emp$ID)]
ID_emp$ID["2930"]
pal_manual_mc["2930"]
mc_emp_int <- intersect(ID_mc$ID, ID_emp$ID)
mc_emp_int
rm(mc_emp_int)
mc_emp_id_int <- intersect(ID_mc$ID, ID_emp$ID)
pal_manual_mc[mc_emp_id_int]
pal_manual_mc[paste0(mc_emp_id_int)]
pal_manual_emp
pal_manual_emp[paste0(mc_emp_id_int)]
pal_manual_emp[paste0(mc_emp_id_int)] <- pal_manual_mc[paste0(mc_emp_id_int)]
pal_manual_emp
pal_manual_mc
ID_trapz <- df_norm |>
filter(ID %in% id2_riemann) |>
select(ID) |>
distinct()
mc_trapz_id_int <- intersect(ID_mc$ID, ID_trapz$ID)
length(ID_mc)
length(ID_mc$ID)
nrow(ID_mc)
pal_manual_trapz <- RColorBrewer::brewer.pal(n = nrow(ID_trapz), name = "Paired")
names(pal_manual_trapz) <- ID_trapz$ID
pal_manual_trapz[paste0(mc_trapz_id_int)] <- pal_manual_mc[paste0(mc_trapz_id_int)]
pal_manual_trapz
pal_manual_mc
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_emp <- df_norm |>
filter(ID %in% id2_emp) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Empirical Mean)')
L2_riemann <- df_norm |>
filter(ID %in% id2_riemann) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Trapezoidal Rule)')
L2_mc
L2_emp
library(tikzDevice)
tikz('cluster2_mc.tex',width=5,height=5, standAlone = TRUE)
plot(L2_mc)
dev.off()
tikz('cluster2_emp.tex',width=5,height=5,standAlone = TRUE)
plot(L2_emp)
dev.off()
tikz('cluster2_riemann.tex',width=5,height=5,standAlone = TRUE)
plot(L2_riemann)
dev.off()
L2_riemann <- df_norm |>
filter(ID %in% id2_riemann) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Trapezoidal Rule)')
L2_riemann
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(pal_manual_mc) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_mc
pal_manual_mc <- RColorBrewer::brewer.pal(n = nrow(ID_mc), name = "Paired")
names(pal_manual_mc) <- ID_mc$ID
pal_manual_mc
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(pal_manual_mc) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_mc
?scale_color_manual
L2_mc <- df_norm |>
filter(ID %in% id2_mc) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(values = pal_manual_mc) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Control Neighbours)')
L2_mc
L2_emp <- df_norm |>
filter(ID %in% id2_emp) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(values = pal_manual_emp) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Empirical Mean)')
L2_emp
L2_riemann <- df_norm |>
filter(ID %in% id2_riemann) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(values = pal_manual_emp) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Trapezoidal Rule)')
L2_riemann
L2_riemann <- df_norm |>
filter(ID %in% id2_riemann) |>
group_by(ID) |>
mutate(ID = as.factor(ID)) |>
ggplot(aes(x = Age, y = Performance, col = ID)) +
geom_point() +
geom_line() +
theme_minimal() +
scale_color_manual(values = pal_manual_trapz) +
theme(plot.title = element_text(hjust = 0.5)) +
ggtitle('Individuals selected in cluster L2 (Trapezoidal Rule)')
L2_riemann
tikz('cluster2_mc.tex',width=5,height=5, standAlone = TRUE)
plot(L2_mc)
dev.off()
tikz('cluster2_emp.tex',width=5,height=5,standAlone = TRUE)
plot(L2_emp)
dev.off()
tikz('cluster2_riemann.tex',width=5,height=5,standAlone = TRUE)
plot(L2_riemann)
dev.off()
knitr::opts_chunk$set(echo = TRUE)
library(fda)
# First focus our attention on average daily temperature for each day of the year
dailytempav = CanadianWeather$dailyAv[,,"Temperature.C"]
#Create the basis functions
tempbasis5 = create.fourier.basis(rangeval = c(0, 365), nbasis = 5)
tempbasis = create.fourier.basis(rangeval = c(0, 365), nbasis = 65)
#Some useful commands for exploring basis objects
plot(tempbasis5)
plot(tempbasis)
summary(tempbasis5)
tempbasis5 == tempbasis
#Setup midday times for each of the days in years
daytime = (1:365) - 0.5
#Suppose we are more interested in the Winter months. Rearrange the standard
#years so that the winter months show up in the middle
JJindex = c(182:365, 1:181)
#Rearrange our data according to new index
tempmat = daily$tempav[JJindex, ]
tempsmooth = smooth.basis(daytime, tempmat, tempbasis)
tempfd = tempsmooth$fd
tempfd$fdnames = list("Day (July 2 to June 30)",
"Weather Station",
"Smoothed Mean temperature (65 bases)")
plot(tempfd, col = 1, lty = 1, main = "Average Daily Temperatures (35 Stations)")
CanadianWeather
# First focus our attention on average daily temperature for each day of the year
dailytempav = CanadianWeather$dailyAv[,,"Temperature.C"]
dailytempav
#Create the basis functions
tempbasis5 = create.fourier.basis(rangeval = c(0, 365), nbasis = 5)
tempbasis = create.fourier.basis(rangeval = c(0, 365), nbasis = 65)
#Some useful commands for exploring basis objects
plot(tempbasis5)
plot(tempbasis)
summary(tempbasis5)
tempbasis5 == tempbasis
#Setup midday times for each of the days in years
daytime = (1:365) - 0.5
plot(tempbasis5)
#Setup midday times for each of the days in years
daytime = (1:365) - 0.5
#Suppose we are more interested in the Winter months. Rearrange the standard
#years so that the winter months show up in the middle
JJindex = c(182:365, 1:181)
#Rearrange our data according to new index
tempmat = daily$tempav[JJindex, ]
tempsmooth = smooth.basis(daytime, tempmat, tempbasis)
tempfd = tempsmooth$fd
tempfd$fdnames = list("Day (July 2 to June 30)",
"Weather Station",
"Smoothed Mean temperature (65 bases)")
plot(tempfd, col = 1, lty = 1, main = "Average Daily Temperatures (35 Stations)")
tempsmoothsmall = smooth.basis(argvals = daytime,
y = tempmat,
fdParobj = tempbasis5)
tempsmoothsmallfd = tempsmoothsmall$fd
tempsmoothsmallfd$fdnames = list("Day (July 2 to June 30)",
"Weather Station",
"Smoothed Mean temperature (5 basis functions)")
plot(tempsmoothsmallfd, col = 1, lty = 1, main = "Average Daily Temperatures (35 Stations)")
?pca.fd
logprec.pcalist
logprec.pcalist = pca.fd(fdobj = logprec.fd, nharm = 2,
centerfns = TRUE)
day5time = seq(0, 365, 5)
logprec.varmat = eval.bifd(day5time, day5time, logprecvar.bifd)
meanlogprec = mean.fd(logprec.fd)
lambda = 1e6
fdParobj = fdPar(daybasis, harmaccelLfd, lambda)
logprecav = CanadianWeather$dailyAv[dayOfYearShifted, , 'log10precip']
#we set up a saturated Fourier basis for the data
dayrange = c(0, 365)
daybasis = create.fourier.basis(dayrange, 365)
# Set up coefficients of the linear differential operator
Lcoef = c(0, (2 * pi / diff(dayrange))^2, 0)
#Convert vector to linear differential operator object
harmaccelLfd = vec2Lfd(Lcoef, dayrange)
#Initialise vector of values
loglam = seq(4, 9, 0.25)
nlam = length(loglam)
dfsave = rep(NA, nlam)
gcvsave = rep(NA, nlam)
# Loop through lambda values
for (ilam in 1:nlam) {
cat(paste('log10 lambda =', loglam[ilam], '\n'))
lambda = 10^loglam[ilam]
fdParobj = fdPar(daybasis, harmaccelLfd, lambda)
smoothlist = smooth.basis(day.5, logprecav, fdParobj)
dfsave[ilam] = smoothlist$df
gcvsave[ilam] = sum(smoothlist$gcv)
}
plot(x = loglam, y = gcvsave, type = "b")
lambda = 1e6
fdParobj = fdPar(daybasis, harmaccelLfd, lambda)
logprec.fit = smooth.basis(day.5, logprecav, fdParobj)
logprec.fd = logprec.fit$fd
fdnames = list("Day (July 1 to June 30)",
"Weather Station = CanadianWeather$place",
"Log 10 Precipitation (mm)")
logprec.fd$fdnames = fdnames
plot(logprec.fd)
meanlogprec = mean.fd(logprec.fd)
# Compute the standard deviation
stddevlogprec = std.fd(logprec.fd)
# Compute the covariance for all points (t,s)
logprecvar.bifd = var.fd(logprec.fd)
# Do some plots
plot(meanlogprec)
# Plot the covariance surface in weeks
weektime = seq(0, 365, length = 53)
logprecvar_mat = eval.bifd(weektime, weektime, logprecvar.bifd)
persp(weektime, weektime, logprecvar_mat,
theta = -45, phi = 25, r = 3, expand = 0.5,
ticktype = 'detailed', xlab = "Day (July 1 to June 30)",
ylab = "Day (July 1 to June 30)", zlab = "variance (log10 precip)")
contour(weektime, weektime, logprecvar_mat)
#can also plot in days as argvals - same shape, just a finer grid
daytime = seq(0, 365, length = 365)
logprecvar_matdays = eval.bifd(daytime, daytime, logprecvar.bifd)
GA::persp3D(daytime, daytime, logprecvar_matdays)
day5time = seq(0, 365, 5)
logprec.varmat = eval.bifd(day5time, day5time, logprecvar.bifd)
contour(day5time, day5time, logprec.varmat,
xlab = "Day (July 1 to June 30)",
ylab = "Day (July 1 to June 30)",
lwd = 2, labcex = 1)
tempprecbifd = var.fd(tempfd, logprec.fd)
tempprecbifd_mat = eval.bifd(weektime, weektime, tempprecbifd)
persp(weektime, weektime, tempprecbifd_mat,
theta = -45, phi = 25, r = 3, expand = 0.5,
ticktype = 'detailed', xlab = "Day (July 1 to June 30)",
ylab = "Day (July 1 to June 30)", zlab = "Cross-Covariance (Temperature / Log Prec")
logprec.pcalist = pca.fd(fdobj = logprec.fd, nharm = 2,
centerfns = TRUE)
# First two eigen-elements account for ~96% of the variation
cumsum(logprec.pcalist$values) / sum(logprec.pcalist$values)
# Plot the first two PCs
plot.pca.fd(logprec.pcalist)
logprec.pcalist
logprec.pcalist$harmonics$coefs
logprec.pcalist$harmonics$basis$basisvalues
logprec.pcalist$harmonics$basis$values
logprec.pcalist$harmonics
str(logprec.pcalist$harmonics)
logprec.pcalist = pca.fd(fdobj = logprec.fd, nharm = 2,
centerfns = TRUE)
# First two eigen-elements account for ~96% of the variation
cumsum(logprec.pcalist$values) / sum(logprec.pcalist$values)
?plot.pca.fd
# Plot the first two PCs
plot.pca.fd(logprec.pcalist, expand == 0)
# Plot the first two PCs
plot.pca.fd(logprec.pcalist, expand = 0)
## Optional: Interpolation
What happens to the quality of our estimates when we take smoothing (or lack of)
knitr::opts_chunk$set(echo = TRUE)
library(refund)
cd4_df = reshape2::melt(cd4)
colnames(cd4_df) = c("curve", "month", "value")
cd4_df_nona = na.omit(cd4_df)
library(tidyverse)
five_obs = cd4_df_nona |>
filter(curve %in% 135:140)
cd4_df_nona |> count(curve) |> summarise(mean_n = mean(n))
ggplot(five_obs, aes(x = month, y = value, color = as.factor(curve))) +
geom_point() +
geom_line() +
xlab("month") + ylab("cd4 counts") +
scale_color_discrete()
library(fdapace)
L1 = MakeFPCAInputs(IDs = cd4_df$curve, tVec = cd4_df$month,
yVec = cd4_df$value, deduplicate = TRUE)
mu_zw = fdapace::GetMeanCurve(Ly = L1$Ly, Lt = L1$Lt,
list(kernel = "epan", methodBwMu = "GCV"))
plot(mu_zw$workGrid, mu_zw$mu, type = "l", xlab = "Month", ylab = "CD4 Counts",
main = "Mean Curve (Smoothed with weighting scheme)")
cov_zw = fdapace::GetCovSurface(Ly = L1$Ly, Lt = L1$Lt,
list(kernel = "epan", methodBwCov = "GCV"))
GA::persp3D(cov_zw$workGrid, cov_zw$workGrid, cov_zw$cov,
xlab = "Month", ylab = "Month", zlab = "Covariance",
main = "Covariance Surface (smoothed by weighting schemes)")
L1
L1$Ly
