KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
warnings()
T_ord$x
KM_surv$surv
KM_surv$surv |> length()
delta_ord |> length()
length(T_ord$x)
n <- 1000        #sample size
l.Y <- 0.3      #parameter of the distribution of of Y
l.C <- 0.5      #parameter of the distribution of of
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
##########Data
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
mu_result <- sapply(seq_len(replic), function(rep) {
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
# good weighting with estimated survival function
KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
n <- 1000        #sample size
l.Y <- 0.3      #parameter of the distribution of of Y
l.C <- 0.5      #parameter of the distribution of of
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
n_replic <- 1000
mu_result <- sapply(seq_len(replic), function(rep) {
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
# good weighting with estimated survival function
KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
#### mean with estimated survival =============================
replic <- 2000
n <- 1000        #sample size
l.Y <- 0.3      #parameter of the distribution of of Y
l.C <- 0.5      #parameter of the distribution of of
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
n_replic <- 1000
#### mean with estimated survival =============================
replic <- 2000
l.Y <- 0.3      #parameter of the distribution of of Y
l.C <- 0.5      #parameter of the distribution of of
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
n_replic <- 1000
##########Data
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
mu_result <- sapply(seq_len(replic), function(rep) {
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
# good weighting with estimated survival function
KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
library(survival)
mu_result <- sapply(seq_len(replic), function(rep) {
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
# good weighting with estimated survival function
KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
warnings()
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
naive_mu1
naive_mu2
# good weighting with estimated survival function
KM_surv <- survfit(Surv(time = T_obs, event = delta_obs) ~ 1,
data = data.frame(time = T_obs,
status = delta_obs))
T_ord <- sort(T_obs, index.return = TRUE)
delta_ord <- delta_obs[T_ord$ix]
length(T_ord)
length(delta_ord)
T_ord
delta_ord
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
opt_mu
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv, na.rm = TRUE) / length(T_ord$x)
opt_mu
length(T_ord$x)
sum(delta_ord * T_ord$x / KM_surv$surv)
delta_ord * T_ord$x / KM_surv$surv
KM_surv$surv
KM_surv$surv[KM_surv$surv == 0] <- .Machine$double.eps
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
opt_mu
KM_surv$surv[KM_surv$surv == 0] <- 0.06
opt_mu <- sum(delta_ord * T_ord$x / KM_surv$surv) / length(T_ord$x)
opt_mu
opt_mu
KM_surv$surv
mean(delta_ord * T_ord$x / KM_surv$surv)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(survival)
###################
###################
# Censoring and IPCW: marginal distribution aspects
###################
###################
##########DGP parameters
n <- 1000        #sample size
l.Y <- 0.3      #parameter of the distribution of of Y
l.C <- 0.5      #parameter of the distribution of of C
tau <- 0.1      #quantile
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
##########Data
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
#' Constructs the exponential survival function
#' @param lambda Numeric, the rate parameter.
#' @param x Vector of evaluation points.
#' @returns Vector, the survival function at the input evaluation points.
#'
surv_exp <- function(lambda, x = seq(0, 2, l = 101)) {
exp(-lambda * x)
}
#' Estimates the empirical CDF, given some weights
#' @param xi Vector of observed points.
#' @param x Vector of evaluation points.
#' @param wi Vector of weights.
#' @param norm_wi Boolean, indicating whether to normalize by the sum of the
#' weights instead of the number of observations.
#' @returns Vector, the empirical cdf on a vector of evaluation points.
#'
emp_cdf <- function(xi, x = seq(0, max(T_obs), l = 101), wi, norm_wi = FALSE) {
if(missing(wi)) {
colMeans(outer(xi, x, FUN = "<="))
} else if (norm_wi) {
colSums(outer(xi, x, FUN = "<=") * wi) / sum(wi)
} else {
colMeans(outer(xi, x, FUN = "<=") * wi)
}
}
xout <- seq(0, 10, l = 501)
F1 <- emp_cdf(xi = T_obs, x = xout)
F2 <- emp_cdf(xi = T_obs, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs, x = xout, wi = delta_obs, norm_wi = TRUE)
surv_vec <- surv_exp(lambda = l.C, x = T_obs)
F_opt <- emp_cdf(xi = T_obs,
x = xout,
wi = delta_obs / surv_vec,
norm_wi = FALSE)
F_true <- 1 - surv_exp(lambda = l.Y, x = xout)
df <- data.frame(x = xout,
F1 = F1,
F2 = F2,
F3 = F3,
F_opt = F_opt,
F_true = F_true) |>
pivot_longer(cols = starts_with("F"),
names_to = "group",
values_to = "value")
ggplot(df, aes(x = x, y = value, color = group)) +
scale_color_manual(values = c("F_true" = "black", "F1" = "red", "F2" = "blue", "F3" = "orange", "F_opt" = "green")) +
geom_step() +
theme_minimal() +
labs(title = "Comparisons of Estimated Distribution Functions",
x = "t",
y = "F(t)")
df
replic <- 2000
mu_y <- 1 / l.Y # true value
n_replic <- 1000 # sample size in each replication
mu_result <- sapply(seq_len(replic), function(rep) {
# generate data
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
# average with observed Ti's
naive_mu1 <- mean(T_obs)
# weighted average with delta obs
naive_mu2 <- sum(delta_obs * T_obs) / sum(delta_obs)
# good weighting
opt_mu <- sum(delta_obs * T_obs / surv_exp(lambda = l.C, x = T_obs)) / length(T_obs)
c('naive_mu1' = naive_mu1,
'naive_mu2' = naive_mu2,
'opt_mu' = opt_mu,
'p_cens' = p_cens)
}) |> t()
mu_df <- mu_result |>
as.data.frame() |>
pivot_longer(cols = naive_mu1:opt_mu,
names_to = "group",
values_to = "estimate")
# Although the optimal weighting is ok, it is more unstable due to outliers
mu_df |>
ggplot(aes(x = group, y = estimate, fill = group)) +
geom_boxplot() +
geom_hline(yintercept = mu_y, col = "red")
# Boxplot removing the outliers at 5% on each end for all guys
mu_df |>
ggplot(aes(x = group, y = estimate, fill = group)) +
geom_boxplot(outlier.shape = NA) +
scale_y_continuous(limits = quantile(mu_df$estimate, c(0.01, 0.99))) +
geom_hline(yintercept = mu_y, col = "red") +
xlab("Estimate Type") +
ylab("Mean Estimate") +
ggtitle("Comparison of estimated means")
mu_result
mu_df |>
group_by(group) |>
summarise(estim = quantile(estimate))
replic <- 2000
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
quant_result <- sapply(seq_len(replic), function(rep) {
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
F1 <- emp_cdf(xi = T_obs$x, x = xout)
F2 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs, norm_wi = TRUE)
F_opt <- emp_cdf(xi = T_obs$x,
x = xout,
wi = delta_obs / surv_exp(lambda = l.C, x = T_obs$x),
norm_wi = FALSE)
q_id1 <- min(which(tau_q <= F1))
q_id2 <- min(which(tau_q <= F2))
q_id3 <- ifelse(min(which(tau_q <= F3)) == NA, 0, min(which(tau_q <= F3)))
q_idopt <- min(which(tau_q <= F_opt))
c("q1" = xout[q_id1],
"q2" = xout[q_id2],
"q3" = xout[q_id3],
"qopt" = xout[q_idopt],
"p_cens" = p_cens
)
})
# returns warning because one of the empirical CDF is shit, and cannot even find the quantiles
# far enough
quant_df <- t(quant_result) |>
as.data.frame() |>
pivot_longer(cols = q1:qopt,
names_to = "method",
values_to = "quantile")
quant_df |>
ggplot(aes(x = method, y = quantile, fill = method)) +
geom_boxplot() +
geom_hline(yintercept = q_true, col = "red")
###### quantiles
replic <- 2000
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
replic <- 2000
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
quant_result <- sapply(seq_len(replic), function(rep) {
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
F1 <- emp_cdf(xi = T_obs$x, x = xout)
F2 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs, norm_wi = TRUE)
F_opt <- emp_cdf(xi = T_obs$x,
x = xout,
wi = delta_obs / surv_exp(lambda = l.C, x = T_obs$x),
norm_wi = FALSE)
q_id1 <- min(which(tau_q <= F1))
q_id2 <- min(which(tau_q <= F2))
q_id3 <- min(which(tau_q <= F3))
q_idopt <- min(which(tau_q <= F_opt))
c("q1" = xout[q_id1],
"q2" = xout[q_id2],
"q3" = xout[q_id3],
"qopt" = xout[q_idopt],
"p_cens" = p_cens
)
})
replic <- 200
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
quant_result <- sapply(seq_len(replic), function(rep) {
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
F1 <- emp_cdf(xi = T_obs$x, x = xout)
F2 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs, norm_wi = TRUE)
F_opt <- emp_cdf(xi = T_obs$x,
x = xout,
wi = delta_obs / surv_exp(lambda = l.C, x = T_obs$x),
norm_wi = FALSE)
q_id1 <- min(which(tau_q <= F1))
q_id2 <- min(which(tau_q <= F2))
q_id3 <- min(which(tau_q <= F3))
q_idopt <- min(which(tau_q <= F_opt))
c("q1" = xout[q_id1],
"q2" = xout[q_id2],
"q3" = xout[q_id3],
"qopt" = xout[q_idopt],
"p_cens" = p_cens
)
})
warnings()
quant_df <- t(quant_result) |>
as.data.frame() |>
pivot_longer(cols = q1:qopt,
names_to = "method",
values_to = "quantile")
quant_df |>
ggplot(aes(x = method, y = quantile, fill = method)) +
geom_boxplot() +
geom_hline(yintercept = q_true, col = "red")
xout[q_id2]
replic <- 200
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
quant_result <- sapply(seq_len(replic), function(rep) {
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
F1 <- emp_cdf(xi = T_obs$x, x = xout)
F2 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs, norm_wi = TRUE)
F_opt <- emp_cdf(xi = T_obs$x,
x = xout,
wi = delta_obs / surv_exp(lambda = l.C, x = T_obs$x),
norm_wi = FALSE)
q_id1 <- min(which(tau_q <= F1))
q_id2 <- min(which(tau_q <= F2))
q_id3 <- min(which(tau_q <= F3))
q_idopt <- min(which(tau_q <= F_opt))
c("q1" = xout[q_id1],
"q2" = ifelse(xout[q_id2] == NA, 0, xout[q_id2]),
"q3" = xout[q_id3],
"qopt" = xout[q_idopt],
"p_cens" = p_cens
)
})
# returns warning because one of the empirical CDF is shit, and cannot even find the quantiles
# far enough
quant_df <- t(quant_result) |>
as.data.frame() |>
pivot_longer(cols = q1:qopt,
names_to = "method",
values_to = "quantile")
quant_df |>
ggplot(aes(x = method, y = quantile, fill = method)) +
geom_boxplot() +
geom_hline(yintercept = q_true, col = "red")
quant_result <- sapply(seq_len(replic), function(rep) {
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
F1 <- emp_cdf(xi = T_obs$x, x = xout)
F2 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs)
F3 <- emp_cdf(xi = T_obs$x, x = xout, wi = delta_obs, norm_wi = TRUE)
F_opt <- emp_cdf(xi = T_obs$x,
x = xout,
wi = delta_obs / surv_exp(lambda = l.C, x = T_obs$x),
norm_wi = FALSE)
q_id1 <- min(which(tau_q <= F1))
q_id2 <- min(which(tau_q <= F2))
q_id3 <- min(which(tau_q <= F3))
q_idopt <- min(which(tau_q <= F_opt))
c("q1" = xout[q_id1],
"q2" = ifelse(is.na(xout[q_id2]), 0, xout[q_id2]),
"q3" = xout[q_id3],
"qopt" = xout[q_idopt],
"p_cens" = p_cens
)
})
quant_df <- t(quant_result) |>
as.data.frame() |>
pivot_longer(cols = q1:qopt,
names_to = "method",
values_to = "quantile")
quant_df |>
ggplot(aes(x = method, y = quantile, fill = method)) +
geom_boxplot() +
geom_hline(yintercept = q_true, col = "red")
warnings()
###### quantiles
replic <- 200
n_replic <- 1000
tau_q <- 0.7
q_true <- -log(1 - tau_q) / l.Y # true quantile of the exponential distribution
xout <- seq(0, 10, l = 201) # evaluation points for empirical CDF
Y <- rexp(n = n_replic, rate = l.Y)
C <- rexp(n = n_replic, rate = l.C)
T_obs <- sort(pmin(Y, C), index.return = TRUE)
delta_obs <- ((Y <= C) * 1)[T_obs$ix]
p_cens <- (length(delta_obs) - sum(delta_obs)) / length(delta_obs)
sapply(seq_along(T_obs), function(k) 1 - (1 / (length(T_obs) - k + 1)))
seq_along(T_obs)
T_obs$x
sapply(seq_along(T_obs), function(k) 1 - (1 / (length(T_obs$x) - k + 1)))
sapply(seq_along(T_obs$x), function(k) 1 - (1 / (length(T_obs$x) - k + 1)))
(1 - (1 / (length(T_obs$x) - k + 1)))^(delta_obs)
sapply(seq_along(T_obs$x), function(k) {
(1 - (1 / (length(T_obs$x) - k + 1)))^(delta_obs[k])
})
?cumprod
cumprod( (1 - (1 / (length(T_obs$x) - k + 1)))^(delta_obs[k]) )
sapply(seq_along(T_obs$x), function(k) {
cumprod((1 - (1 / (length(T_obs$x) - k + 1)))^(delta_obs[k]))
})
